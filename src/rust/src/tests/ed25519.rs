use crate::librustzcash_zebra_crypto_sign_verify_detached;

#[test]
fn test_weird_signature() {
    // This is a signature from hell.

    // A = (0, 1) encoded with high bit set, even though the x-coordinate is 0
    let pk = [
        0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x80
    ];

    // R = (0, -1) encoded with high bit set, even though the x-coordinate is 0
    // s = 0
    let mut sig = [
        0xec, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00
    ];
    
    assert_eq!(librustzcash_zebra_crypto_sign_verify_detached(
        &sig, &0xff, 1, &pk
    ), 0);

    // Screw with the signature to exercise verification failure
    sig[32] = 0x01; // wrong (but a valid) s value

    assert_eq!(librustzcash_zebra_crypto_sign_verify_detached(
        &sig, &0xff, 1, &pk
    ), 1);
}
